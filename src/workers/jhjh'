1: #extension GL_OES_standard_derivatives : enable
2: #extension GL_EXT_shader_texture_lod : enable
3: precision highp float;
4: precision highp int;
5: #define SHADER_NAME MeshStandardMaterial
6: #define STANDARD 
7: #define GAMMA_FACTOR 2
8: #define USE_MAP
9: #define USE_ENVMAP
10: #define ENVMAP_TYPE_CUBE_UV
11: #define ENVMAP_MODE_REFLECTION
12: #define ENVMAP_BLENDING_MULTIPLY
13: #define TEXTURE_LOD_EXT
14: uniform mat4 viewMatrix;
15: uniform vec3 cameraPosition;
16: #define TONE_MAPPING
17: 
18: #ifndef saturate
19: 	#define saturate(a) clamp( a, 0.0, 1.0 )
20: #endif
21: 
22: uniform float toneMappingExposure;
23: uniform float toneMappingWhitePoint;
24: 
25: // exposure only
26: vec3 LinearToneMapping( vec3 color ) {
27: 
28: 	return toneMappingExposure * color;
29: 
30: }
31: 
32: // source: https://www.cs.utah.edu/~reinhard/cdrom/
33: vec3 ReinhardToneMapping( vec3 color ) {
34: 
35: 	color *= toneMappingExposure;
36: 	return saturate( color / ( vec3( 1.0 ) + color ) );
37: 
38: }
39: 
40: // source: http://filmicgames.com/archives/75
41: #define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
42: vec3 Uncharted2ToneMapping( vec3 color ) {
43: 
44: 	// John Hable's filmic operator from Uncharted 2 video game
45: 	color *= toneMappingExposure;
46: 	return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );
47: 
48: }
49: 
50: // source: http://filmicgames.com/archives/75
51: vec3 OptimizedCineonToneMapping( vec3 color ) {
52: 
53: 	// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson
54: 	color *= toneMappingExposure;
55: 	color = max( vec3( 0.0 ), color - 0.004 );
56: 	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
57: 
58: }
59: 
60: // source: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
61: vec3 ACESFilmicToneMapping( vec3 color ) {
62: 
63: 	color *= toneMappingExposure;
64: 	return saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );
65: 
66: }
67: 
68: vec3 toneMapping( vec3 color ) { return LinearToneMapping( color ); }
69: 
70: // For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/
71: 
72: vec4 LinearToLinear( in vec4 value ) {
73: 	return value;
74: }
75: 
76: vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
77: 	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
78: }
79: 
80: vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
81: 	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
82: }
83: 
84: vec4 sRGBToLinear( in vec4 value ) {
85: 	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
86: }
87: 
88: vec4 LinearTosRGB( in vec4 value ) {
89: 	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
90: }
91: 
92: vec4 RGBEToLinear( in vec4 value ) {
93: 	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
94: }
95: 
96: vec4 LinearToRGBE( in vec4 value ) {
97: 	float maxComponent = max( max( value.r, value.g ), value.b );
98: 	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
99: 	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
100: //  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );
101: }
102: 
103: // reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html
104: vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
105: 	return vec4( value.rgb * value.a * maxRange, 1.0 );
106: }
107: 
108: vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
109: 	float maxRGB = max( value.r, max( value.g, value.b ) );
110: 	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
111: 	M = ceil( M * 255.0 ) / 255.0;
112: 	return vec4( value.rgb / ( M * maxRange ), M );
113: }
114: 
115: // reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html
116: vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
117: 	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
118: }
119: 
120: vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
121: 	float maxRGB = max( value.r, max( value.g, value.b ) );
122: 	float D = max( maxRange / maxRGB, 1.0 );
123: 	D = min( floor( D ) / 255.0, 1.0 );
124: 	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
125: }
126: 
127: // LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html
128: 
129: // M matrix, for encoding
130: const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
131: vec4 LinearToLogLuv( in vec4 value )  {
132: 	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
133: 	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
134: 	vec4 vResult;
135: 	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
136: 	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
137: 	vResult.w = fract( Le );
138: 	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
139: 	return vResult;
140: }
141: 
142: // Inverse M matrix, for decoding
143: const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
144: vec4 LogLuvToLinear( in vec4 value ) {
145: 	float Le = value.z * 255.0 + value.w;
146: 	vec3 Xp_Y_XYZp;
147: 	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
148: 	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
149: 	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
150: 	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
151: 	return vec4( max( vRGB, 0.0 ), 1.0 );
152: }
153: 
154: vec4 matcapTexelToLinear( vec4 value ) { return GammaToLinear( value, float( GAMMA_FACTOR ) ); }
155: vec4 envMapTexelToLinear( vec4 value ) { return GammaToLinear( value, float( GAMMA_FACTOR ) ); }
156: vec4 emissiveMapTexelToLinear( vec4 value ) { return GammaToLinear( value, float( GAMMA_FACTOR ) ); }
157: vec4 linearToOutputTexel( vec4 value ) { return LinearToGamma( value, float( GAMMA_FACTOR ) ); }
158: 
159: 
160: #define PHYSICAL
161: 
162: uniform vec3 diffuse;
163: uniform vec3 emissive;
164: uniform float roughness;
165: uniform float metalness;
166: uniform float opacity;
167: 
168: #ifndef STANDARD
169: 	uniform float clearCoat;
170: 	uniform float clearCoatRoughness;
171: #endif
172: 
173: varying vec3 vViewPosition;
174: 
175: #ifndef FLAT_SHADED
176: 
177: 	varying vec3 vNormal;
178: 
179: 	#ifdef USE_TANGENT
180: 
181: 		varying vec3 vTangent;
182: 		varying vec3 vBitangent;
183: 
184: 	#endif
185: 
186: #endif
187: 
188: 
189: #define PI 3.14159265359
190: #define PI2 6.28318530718
191: #define PI_HALF 1.5707963267949
192: #define RECIPROCAL_PI 0.31830988618
193: #define RECIPROCAL_PI2 0.15915494
194: #define LOG2 1.442695
195: #define EPSILON 1e-6
196: 
197: #define saturate(a) clamp( a, 0.0, 1.0 )
198: #define whiteCompliment(a) ( 1.0 - saturate( a ) )
199: 
200: float pow2( const in float x ) { return x*x; }
201: float pow3( const in float x ) { return x*x*x; }
202: float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
203: float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
204: // expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.
205: // do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
206: highp float rand( const in vec2 uv ) {
207: 	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
208: 	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
209: 	return fract(sin(sn) * c);
210: }
211: 
212: struct IncidentLight {
213: 	vec3 color;
214: 	vec3 direction;
215: 	bool visible;
216: };
217: 
218: struct ReflectedLight {
219: 	vec3 directDiffuse;
220: 	vec3 directSpecular;
221: 	vec3 indirectDiffuse;
222: 	vec3 indirectSpecular;
223: };
224: 
225: struct GeometricContext {
226: 	vec3 position;
227: 	vec3 normal;
228: 	vec3 viewDir;
229: };
230: 
231: vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
232: 
233: 	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
234: 
235: }
236: 
237: // http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
238: vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
239: 
240: 	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
241: 
242: }
243: 
244: vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
245: 
246: 	float distance = dot( planeNormal, point - pointOnPlane );
247: 
248: 	return - distance * planeNormal + point;
249: 
250: }
251: 
252: float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
253: 
254: 	return sign( dot( point - pointOnPlane, planeNormal ) );
255: 
256: }
257: 
258: vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
259: 
260: 	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
261: 
262: }
263: 
264: mat3 transposeMat3( const in mat3 m ) {
265: 
266: 	mat3 tmp;
267: 
268: 	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
269: 	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
270: 	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
271: 
272: 	return tmp;
273: 
274: }
275: 
276: // https://en.wikipedia.org/wiki/Relative_luminance
277: float linearToRelativeLuminance( const in vec3 color ) {
278: 
279: 	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
280: 
281: 	return dot( weights, color.rgb );
282: 
283: }
284: 
285: 
286: vec3 packNormalToRGB( const in vec3 normal ) {
287: 	return normalize( normal ) * 0.5 + 0.5;
288: }
289: 
290: vec3 unpackRGBToNormal( const in vec3 rgb ) {
291: 	return 2.0 * rgb.xyz - 1.0;
292: }
293: 
294: const float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)
295: const float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)
296: 
297: const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );
298: const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
299: 
300: const float ShiftRight8 = 1. / 256.;
301: 
302: vec4 packDepthToRGBA( const in float v ) {
303: 	vec4 r = vec4( fract( v * PackFactors ), v );
304: 	r.yzw -= r.xyz * ShiftRight8; // tidy overflow
305: 	return r * PackUpscale;
306: }
307: 
308: float unpackRGBAToDepth( const in vec4 v ) {
309: 	return dot( v, UnpackFactors );
310: }
311: 
312: // NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions
313: 
314: float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
315: 	return ( viewZ + near ) / ( near - far );
316: }
317: float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
318: 	return linearClipZ * ( near - far ) - near;
319: }
320: 
321: float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
322: 	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
323: }
324: float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
325: 	return ( near * far ) / ( ( far - near ) * invClipZ - far );
326: }
327: 
328: 
329: #if defined( DITHERING )
330: 
331: 	// based on https://www.shadertoy.com/view/MslGR8
332: 	vec3 dithering( vec3 color ) {
333: 		//Calculate grid position
334: 		float grid_position = rand( gl_FragCoord.xy );
335: 
336: 		//Shift the individual colors differently, thus making it even harder to see the dithering pattern
337: 		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
338: 
339: 		//modify shift acording to grid position.
340: 		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
341: 
342: 		//shift the color by dither_shift
343: 		return color + dither_shift_RGB;
344: 	}
345: 
346: #endif
347: 
348: 
349: #ifdef USE_COLOR
350: 
351: 	varying vec3 vColor;
352: 
353: #endif
354: 
355: 
356: #if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
357: 
358: 	varying vec2 vUv;
359: 
360: #endif
361: 
362: 
363: #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
364: 
365: 	varying vec2 vUv2;
366: 
367: #endif
368: 
369: 
370: #ifdef USE_MAP
371: 
372: 	uniform sampler2D map;
373: 
374: #endif
375: 
376: 
377: #ifdef USE_ALPHAMAP
378: 
379: 	uniform sampler2D alphaMap;
380: 
381: #endif
382: 
383: 
384: #ifdef USE_AOMAP
385: 
386: 	uniform sampler2D aoMap;
387: 	uniform float aoMapIntensity;
388: 
389: #endif
390: 
391: 
392: #ifdef USE_LIGHTMAP
393: 
394: 	uniform sampler2D lightMap;
395: 	uniform float lightMapIntensity;
396: 
397: #endif
398: 
399: 
400: #ifdef USE_EMISSIVEMAP
401: 
402: 	uniform sampler2D emissiveMap;
403: 
404: #endif
405: 
406: 
407: 
408: // Analytical approximation of the DFG LUT, one half of the
409: // split-sum approximation used in indirect specular lighting.
410: // via 'environmentBRDF' from "Physically Based Shading on Mobile"
411: // https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile
412: vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
413: 	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
414: 
415: 	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
416: 
417: 	vec4 r = roughness * c0 + c1;
418: 
419: 	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
420: 
421: 	return vec2( -1.04, 1.04 ) * a004 + r.zw;
422: 
423: }
424: 
425: float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
426: 
427: #if defined ( PHYSICALLY_CORRECT_LIGHTS )
428: 
429: 	// based upon Frostbite 3 Moving to Physically-based Rendering
430: 	// page 32, equation 26: E[window1]
431: 	// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
432: 	// this is intended to be used on spot and point lights who are represented as luminous intensity
433: 	// but who must be converted to luminous irradiance for surface lighting calculation
434: 	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
435: 
436: 	if( cutoffDistance > 0.0 ) {
437: 
438: 		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
439: 
440: 	}
441: 
442: 	return distanceFalloff;
443: 
444: #else
445: 
446: 	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
447: 
448: 		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
449: 
450: 	}
451: 
452: 	return 1.0;
453: 
454: #endif
455: 
456: }
457: 
458: vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
459: 
460: 	return RECIPROCAL_PI * diffuseColor;
461: 
462: } // validated
463: 
464: vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
465: 
466: 	// Original approximation by Christophe Schlick '94
467: 	// float fresnel = pow( 1.0 - dotLH, 5.0 );
468: 
469: 	// Optimized variant (presented by Epic at SIGGRAPH '13)
470: 	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
471: 	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
472: 
473: 	return ( 1.0 - specularColor ) * fresnel + specularColor;
474: 
475: } // validated
476: 
477: // Microfacet Models for Refraction through Rough Surfaces - equation (34)
478: // http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
479: // alpha is "roughness squared" in Disney’s reparameterization
480: float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
481: 
482: 	// geometry term (normalized) = G(l)⋅G(v) / 4(n⋅l)(n⋅v)
483: 	// also see #12151
484: 
485: 	float a2 = pow2( alpha );
486: 
487: 	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
488: 	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
489: 
490: 	return 1.0 / ( gl * gv );
491: 
492: } // validated
493: 
494: // Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2
495: // https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
496: float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
497: 
498: 	float a2 = pow2( alpha );
499: 
500: 	// dotNL and dotNV are explicitly swapped. This is not a mistake.
501: 	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
502: 	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
503: 
504: 	return 0.5 / max( gv + gl, EPSILON );
505: 
506: }
507: 
508: // Microfacet Models for Refraction through Rough Surfaces - equation (33)
509: // http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
510: // alpha is "roughness squared" in Disney’s reparameterization
511: float D_GGX( const in float alpha, const in float dotNH ) {
512: 
513: 	float a2 = pow2( alpha );
514: 
515: 	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1
516: 
517: 	return RECIPROCAL_PI * a2 / pow2( denom );
518: 
519: }
520: 
521: // GGX Distribution, Schlick Fresnel, GGX-Smith Visibility
522: vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {
523: 
524: 	float alpha = pow2( roughness ); // UE4's roughness
525: 
526: 	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
527: 
528: 	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );
529: 	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
530: 	float dotNH = saturate( dot( geometry.normal, halfDir ) );
531: 	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
532: 
533: 	vec3 F = F_Schlick( specularColor, dotLH );
534: 
535: 	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
536: 
537: 	float D = D_GGX( alpha, dotNH );
538: 
539: 	return F * ( G * D );
540: 
541: } // validated
542: 
543: // Rect Area Light
544: 
545: // Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
546: // by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
547: // code: https://github.com/selfshadow/ltc_code/
548: 
549: vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
550: 
551: 	const float LUT_SIZE  = 64.0;
552: 	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
553: 	const float LUT_BIAS  = 0.5 / LUT_SIZE;
554: 
555: 	float dotNV = saturate( dot( N, V ) );
556: 
557: 	// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )
558: 	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
559: 
560: 	uv = uv * LUT_SCALE + LUT_BIAS;
561: 
562: 	return uv;
563: 
564: }
565: 
566: float LTC_ClippedSphereFormFactor( const in vec3 f ) {
567: 
568: 	// Real-Time Area Lighting: a Journey from Research to Production (p.102)
569: 	// An approximation of the form factor of a horizon-clipped rectangle.
570: 
571: 	float l = length( f );
572: 
573: 	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
574: 
575: }
576: 
577: vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
578: 
579: 	float x = dot( v1, v2 );
580: 
581: 	float y = abs( x );
582: 
583: 	// rational polynomial approximation to theta / sin( theta ) / 2PI
584: 	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
585: 	float b = 3.4175940 + ( 4.1616724 + y ) * y;
586: 	float v = a / b;
587: 
588: 	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
589: 
590: 	return cross( v1, v2 ) * theta_sintheta;
591: 
592: }
593: 
594: vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
595: 
596: 	// bail if point is on back side of plane of light
597: 	// assumes ccw winding order of light vertices
598: 	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
599: 	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
600: 	vec3 lightNormal = cross( v1, v2 );
601: 
602: 	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
603: 
604: 	// construct orthonormal basis around N
605: 	vec3 T1, T2;
606: 	T1 = normalize( V - N * dot( V, N ) );
607: 	T2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system
608: 
609: 	// compute transform
610: 	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
611: 
612: 	// transform rect
613: 	vec3 coords[ 4 ];
614: 	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
615: 	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
616: 	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
617: 	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
618: 
619: 	// project rect onto sphere
620: 	coords[ 0 ] = normalize( coords[ 0 ] );
621: 	coords[ 1 ] = normalize( coords[ 1 ] );
622: 	coords[ 2 ] = normalize( coords[ 2 ] );
623: 	coords[ 3 ] = normalize( coords[ 3 ] );
624: 
625: 	// calculate vector form factor
626: 	vec3 vectorFormFactor = vec3( 0.0 );
627: 	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
628: 	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
629: 	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
630: 	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
631: 
632: 	// adjust for horizon clipping
633: 	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
634: 	return vec3( result );
635: 
636: }
637: 
638: // End Rect Area Light
639: 
640: // ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile
641: vec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {
642: 
643: 	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
644: 
645: 	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
646: 
647: 	return specularColor * brdf.x + brdf.y;
648: 
649: } // validated
650: 
651: // Fdez-Agüera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
652: // Approximates multiscattering in order to preserve energy.
653: // http://www.jcgt.org/published/0008/01/03/
654: void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
655: 
656: 	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
657: 
658: 	vec3 F = F_Schlick( specularColor, dotNV );
659: 	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
660: 	vec3 FssEss = F * brdf.x + brdf.y;
661: 
662: 	float Ess = brdf.x + brdf.y;
663: 	float Ems = 1.0 - Ess;
664: 
665: 	// Paper incorrect indicates coefficient is PI/21, and will
666: 	// be corrected to 1/21 in future updates.
667: 	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619; // 1/21
668: 	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
669: 
670: 	singleScatter += FssEss;
671: 	multiScatter += Fms * Ems;
672: 
673: }
674: 
675: float G_BlinnPhong_Implicit(  ) {
676: 
677: 	// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)
678: 	return 0.25;
679: 
680: }
681: 
682: float D_BlinnPhong( const in float shininess, const in float dotNH ) {
683: 
684: 	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
685: 
686: }
687: 
688: vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
689: 
690: 	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
691: 
692: 	//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );
693: 	//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
694: 	float dotNH = saturate( dot( geometry.normal, halfDir ) );
695: 	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
696: 
697: 	vec3 F = F_Schlick( specularColor, dotLH );
698: 
699: 	float G = G_BlinnPhong_Implicit(  );
700: 
701: 	float D = D_BlinnPhong( shininess, dotNH );
702: 
703: 	return F * ( G * D );
704: 
705: } // validated
706: 
707: // source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html
708: float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
709: 	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
710: }
711: 
712: float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
713: 	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
714: }
715: 
716: 
717: #ifdef ENVMAP_TYPE_CUBE_UV
718: 
719: #define cubeUV_textureSize (1024.0)
720: 
721: int getFaceFromDirection(vec3 direction) {
722: 	vec3 absDirection = abs(direction);
723: 	int face = -1;
724: 	if( absDirection.x > absDirection.z ) {
725: 		if(absDirection.x > absDirection.y )
726: 			face = direction.x > 0.0 ? 0 : 3;
727: 		else
728: 			face = direction.y > 0.0 ? 1 : 4;
729: 	}
730: 	else {
731: 		if(absDirection.z > absDirection.y )
732: 			face = direction.z > 0.0 ? 2 : 5;
733: 		else
734: 			face = direction.y > 0.0 ? 1 : 4;
735: 	}
736: 	return face;
737: }
738: #define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)
739: #define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))
740: 
741: vec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {
742: 	float scale = exp2(cubeUV_maxLods1 - roughnessLevel);
743: 	float dxRoughness = dFdx(roughness);
744: 	float dyRoughness = dFdy(roughness);
745: 	vec3 dx = dFdx( vec * scale * dxRoughness );
746: 	vec3 dy = dFdy( vec * scale * dyRoughness );
747: 	float d = max( dot( dx, dx ), dot( dy, dy ) );
748: 	// Clamp the value to the max mip level counts. hard coded to 6 mips
749: 	d = clamp(d, 1.0, cubeUV_rangeClamp);
750: 	float mipLevel = 0.5 * log2(d);
751: 	return vec2(floor(mipLevel), fract(mipLevel));
752: }
753: 
754: #define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)
755: #define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)
756: 
757: vec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {
758: 	mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;
759: 	float a = 16.0 * cubeUV_rcpTextureSize;
760: 
761: 	vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );
762: 	vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;
763: 	// float powScale = exp2(roughnessLevel + mipLevel);
764: 	float powScale = exp2_packed.x * exp2_packed.y;
765: 	// float scale =  1.0 / exp2(roughnessLevel + 2.0 + mipLevel);
766: 	float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;
767: 	// float mipOffset = 0.75*(1.0 - 1.0/exp2(mipLevel))/exp2(roughnessLevel);
768: 	float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;
769: 
770: 	bool bRes = mipLevel == 0.0;
771: 	scale =  bRes && (scale < a) ? a : scale;
772: 
773: 	vec3 r;
774: 	vec2 offset;
775: 	int face = getFaceFromDirection(direction);
776: 
777: 	float rcpPowScale = 1.0 / powScale;
778: 
779: 	if( face == 0) {
780: 		r = vec3(direction.x, -direction.z, direction.y);
781: 		offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);
782: 		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;
783: 	}
784: 	else if( face == 1) {
785: 		r = vec3(direction.y, direction.x, direction.z);
786: 		offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);
787: 		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;
788: 	}
789: 	else if( face == 2) {
790: 		r = vec3(direction.z, direction.x, direction.y);
791: 		offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);
792: 		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;
793: 	}
794: 	else if( face == 3) {
795: 		r = vec3(direction.x, direction.z, direction.y);
796: 		offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);
797: 		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;
798: 	}
799: 	else if( face == 4) {
800: 		r = vec3(direction.y, direction.x, -direction.z);
801: 		offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);
802: 		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;
803: 	}
804: 	else {
805: 		r = vec3(direction.z, -direction.x, direction.y);
806: 		offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);
807: 		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;
808: 	}
809: 	r = normalize(r);
810: 	float texelOffset = 0.5 * cubeUV_rcpTextureSize;
811: 	vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;
812: 	vec2 base = offset + vec2( texelOffset );
813: 	return base + s * ( scale - 2.0 * texelOffset );
814: }
815: 
816: #define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)
817: 
818: vec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {
819: 	float roughnessVal = roughness* cubeUV_maxLods3;
820: 	float r1 = floor(roughnessVal);
821: 	float r2 = r1 + 1.0;
822: 	float t = fract(roughnessVal);
823: 	vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);
824: 	float s = mipInfo.y;
825: 	float level0 = mipInfo.x;
826: 	float level1 = level0 + 1.0;
827: 	level1 = level1 > 5.0 ? 5.0 : level1;
828: 
829: 	// round to nearest mipmap if we are not interpolating.
830: 	level0 += min( floor( s + 0.5 ), 5.0 );
831: 
832: 	// Tri linear interpolation.
833: 	vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);
834: 	vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));
835: 
836: 	vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);
837: 	vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));
838: 
839: 	vec4 result = mix(color10, color20, t);
840: 
841: 	return vec4(result.rgb, 1.0);
842: }
843: 
844: #endif
845: 
846: 
847: #if defined( USE_ENVMAP ) || defined( PHYSICAL )
848: 	uniform float reflectivity;
849: 	uniform float envMapIntensity;
850: #endif
851: 
852: #ifdef USE_ENVMAP
853: 
854: 	#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )
855: 		varying vec3 vWorldPosition;
856: 	#endif
857: 
858: 	#ifdef ENVMAP_TYPE_CUBE
859: 		uniform samplerCube envMap;
860: 	#else
861: 		uniform sampler2D envMap;
862: 	#endif
863: 	uniform float flipEnvMap;
864: 	uniform int maxMipLevel;
865: 
866: 	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )
867: 		uniform float refractionRatio;
868: 	#else
869: 		varying vec3 vReflect;
870: 	#endif
871: 
872: #endif
873: 
874: 
875: #if defined( USE_ENVMAP ) && defined( PHYSICAL )
876: 
877: 	vec3 getLightProbeIndirectIrradiance(  const in GeometricContext geometry, const in int maxMIPLevel ) {
878: 
879: 		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
880: 
881: 		#ifdef ENVMAP_TYPE_CUBE
882: 
883: 			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
884: 
885: 			// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level
886: 			// of a specular cubemap, or just the default level of a specially created irradiance cubemap.
887: 
888: 			#ifdef TEXTURE_LOD_EXT
889: 
890: 				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
891: 
892: 			#else
893: 
894: 				// force the bias high to get the last LOD level as it is the most blurred.
895: 				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
896: 
897: 			#endif
898: 
899: 			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
900: 
901: 		#elif defined( ENVMAP_TYPE_CUBE_UV )
902: 
903: 			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
904: 			vec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );
905: 
906: 		#else
907: 
908: 			vec4 envMapColor = vec4( 0.0 );
909: 
910: 		#endif
911: 
912: 		return PI * envMapColor.rgb * envMapIntensity;
913: 
914: 	}
915: 
916: 	// taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html
917: 	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {
918: 
919: 		//float envMapWidth = pow( 2.0, maxMIPLevelScalar );
920: 		//float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );
921: 
922: 		float maxMIPLevelScalar = float( maxMIPLevel );
923: 		float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );
924: 
925: 		// clamp to allowable LOD ranges.
926: 		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
927: 
928: 	}
929: 
930: 	vec3 getLightProbeIndirectRadiance(  const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {
931: 
932: 		#ifdef ENVMAP_MODE_REFLECTION
933: 
934: 			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );
935: 
936: 		#else
937: 
938: 			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );
939: 
940: 		#endif
941: 
942: 		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
943: 
944: 		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );
945: 
946: 		#ifdef ENVMAP_TYPE_CUBE
947: 
948: 			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
949: 
950: 			#ifdef TEXTURE_LOD_EXT
951: 
952: 				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
953: 
954: 			#else
955: 
956: 				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
957: 
958: 			#endif
959: 
960: 			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
961: 
962: 		#elif defined( ENVMAP_TYPE_CUBE_UV )
963: 
964: 			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
965: 			vec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));
966: 
967: 		#elif defined( ENVMAP_TYPE_EQUIREC )
968: 
969: 			vec2 sampleUV;
970: 			sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
971: 			sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;
972: 
973: 			#ifdef TEXTURE_LOD_EXT
974: 
975: 				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );
976: 
977: 			#else
978: 
979: 				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );
980: 
981: 			#endif
982: 
983: 			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
984: 
985: 		#elif defined( ENVMAP_TYPE_SPHERE )
986: 
987: 			vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );
988: 
989: 			#ifdef TEXTURE_LOD_EXT
990: 
991: 				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );
992: 
993: 			#else
994: 
995: 				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );
996: 
997: 			#endif
998: 
999: 			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
1000: 
1001: 		#endif
1002: 
1003: 		return envMapColor.rgb * envMapIntensity;
1004: 
1005: 	}
1006: 
1007: #endif
1008: 
1009: 
1010: #ifdef USE_FOG
1011: 
1012: 	uniform vec3 fogColor;
1013: 	varying float fogDepth;
1014: 
1015: 	#ifdef FOG_EXP2
1016: 
1017: 		uniform float fogDensity;
1018: 
1019: 	#else
1020: 
1021: 		uniform float fogNear;
1022: 		uniform float fogFar;
1023: 
1024: 	#endif
1025: 
1026: #endif
1027: 
1028: 
1029: uniform vec3 ambientLightColor;
1030: 
1031: vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
1032: 
1033: 	vec3 irradiance = ambientLightColor;
1034: 
1035: 	#ifndef PHYSICALLY_CORRECT_LIGHTS
1036: 
1037: 		irradiance *= PI;
1038: 
1039: 	#endif
1040: 
1041: 	return irradiance;
1042: 
1043: }
1044: 
1045: #if 0 > 0
1046: 
1047: 	struct DirectionalLight {
1048: 		vec3 direction;
1049: 		vec3 color;
1050: 
1051: 		int shadow;
1052: 		float shadowBias;
1053: 		float shadowRadius;
1054: 		vec2 shadowMapSize;
1055: 	};
1056: 
1057: 	uniform DirectionalLight directionalLights[ 0 ];
1058: 
1059: 	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
1060: 
1061: 		directLight.color = directionalLight.color;
1062: 		directLight.direction = directionalLight.direction;
1063: 		directLight.visible = true;
1064: 
1065: 	}
1066: 
1067: #endif
1068: #if 0 > 0
1069: 
1070: 	struct PointLight {
1071: 		vec3 position;
1072: 		vec3 color;
1073: 		float distance;
1074: 		float decay;
1075: 
1076: 		int shadow;
1077: 		float shadowBias;
1078: 		float shadowRadius;
1079: 		vec2 shadowMapSize;
1080: 		float shadowCameraNear;
1081: 		float shadowCameraFar;
1082: 	};
1083: 
1084: 	uniform PointLight pointLights[ 0 ];
1085: 
1086: 	// directLight is an out parameter as having it as a return value caused compiler errors on some devices
1087: 	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
1088: 
1089: 		vec3 lVector = pointLight.position - geometry.position;
1090: 		directLight.direction = normalize( lVector );
1091: 
1092: 		float lightDistance = length( lVector );
1093: 
1094: 		directLight.color = pointLight.color;
1095: 		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
1096: 		directLight.visible = ( directLight.color != vec3( 0.0 ) );
1097: 
1098: 	}
1099: 
1100: #endif
1101: #if 0 > 0
1102: 
1103: 	struct SpotLight {
1104: 		vec3 position;
1105: 		vec3 direction;
1106: 		vec3 color;
1107: 		float distance;
1108: 		float decay;
1109: 		float coneCos;
1110: 		float penumbraCos;
1111: 
1112: 		int shadow;
1113: 		float shadowBias;
1114: 		float shadowRadius;
1115: 		vec2 shadowMapSize;
1116: 	};
1117: 
1118: 	uniform SpotLight spotLights[ 0 ];
1119: 
1120: 	// directLight is an out parameter as having it as a return value caused compiler errors on some devices
1121: 	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {
1122: 
1123: 		vec3 lVector = spotLight.position - geometry.position;
1124: 		directLight.direction = normalize( lVector );
1125: 
1126: 		float lightDistance = length( lVector );
1127: 		float angleCos = dot( directLight.direction, spotLight.direction );
1128: 
1129: 		if ( angleCos > spotLight.coneCos ) {
1130: 
1131: 			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
1132: 
1133: 			directLight.color = spotLight.color;
1134: 			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
1135: 			directLight.visible = true;
1136: 
1137: 		} else {
1138: 
1139: 			directLight.color = vec3( 0.0 );
1140: 			directLight.visible = false;
1141: 
1142: 		}
1143: 	}
1144: 
1145: #endif
1146: #if 0 > 0
1147: 
1148: 	struct RectAreaLight {
1149: 		vec3 color;
1150: 		vec3 position;
1151: 		vec3 halfWidth;
1152: 		vec3 halfHeight;
1153: 	};
1154: 
1155: 	// Pre-computed values of LinearTransformedCosine approximation of BRDF
1156: 	// BRDF approximation Texture is 64x64
1157: 	uniform sampler2D ltc_1; // RGBA Float
1158: 	uniform sampler2D ltc_2; // RGBA Float
1159: 
1160: 	uniform RectAreaLight rectAreaLights[ 0 ];
1161: 
1162: #endif
1163: #if 0 > 0
1164: 
1165: 	struct HemisphereLight {
1166: 		vec3 direction;
1167: 		vec3 skyColor;
1168: 		vec3 groundColor;
1169: 	};
1170: 
1171: 	uniform HemisphereLight hemisphereLights[ 0 ];
1172: 
1173: 	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
1174: 
1175: 		float dotNL = dot( geometry.normal, hemiLight.direction );
1176: 		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
1177: 
1178: 		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
1179: 
1180: 		#ifndef PHYSICALLY_CORRECT_LIGHTS
1181: 
1182: 			irradiance *= PI;
1183: 
1184: 		#endif
1185: 
1186: 		return irradiance;
1187: 
1188: 	}
1189: 
1190: #endif
1191: 
1192: 
1193: struct PhysicalMaterial {
1194: 
1195: 	vec3	diffuseColor;
1196: 	float	specularRoughness;
1197: 	vec3	specularColor;
1198: 
1199: 	#ifndef STANDARD
1200: 		float clearCoat;
1201: 		float clearCoatRoughness;
1202: 	#endif
1203: 
1204: };
1205: 
1206: #define MAXIMUM_SPECULAR_COEFFICIENT 0.16
1207: #define DEFAULT_SPECULAR_COEFFICIENT 0.04
1208: 
1209: // Clear coat directional hemishperical reflectance (this approximation should be improved)
1210: float clearCoatDHRApprox( const in float roughness, const in float dotNL ) {
1211: 
1212: 	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
1213: 
1214: }
1215: 
1216: #if 0 > 0
1217: 
1218: 	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
1219: 
1220: 		vec3 normal = geometry.normal;
1221: 		vec3 viewDir = geometry.viewDir;
1222: 		vec3 position = geometry.position;
1223: 		vec3 lightPos = rectAreaLight.position;
1224: 		vec3 halfWidth = rectAreaLight.halfWidth;
1225: 		vec3 halfHeight = rectAreaLight.halfHeight;
1226: 		vec3 lightColor = rectAreaLight.color;
1227: 		float roughness = material.specularRoughness;
1228: 
1229: 		vec3 rectCoords[ 4 ];
1230: 		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction
1231: 		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
1232: 		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
1233: 		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
1234: 
1235: 		vec2 uv = LTC_Uv( normal, viewDir, roughness );
1236: 
1237: 		vec4 t1 = texture2D( ltc_1, uv );
1238: 		vec4 t2 = texture2D( ltc_2, uv );
1239: 
1240: 		mat3 mInv = mat3(
1241: 			vec3( t1.x, 0, t1.y ),
1242: 			vec3(    0, 1,    0 ),
1243: 			vec3( t1.z, 0, t1.w )
1244: 		);
1245: 
1246: 		// LTC Fresnel Approximation by Stephen Hill
1247: 		// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf
1248: 		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
1249: 
1250: 		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
1251: 
1252: 		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
1253: 
1254: 	}
1255: 
1256: #endif
1257: 
1258: void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
1259: 
1260: 	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
1261: 
1262: 	vec3 irradiance = dotNL * directLight.color;
1263: 
1264: 	#ifndef PHYSICALLY_CORRECT_LIGHTS
1265: 
1266: 		irradiance *= PI; // punctual light
1267: 
1268: 	#endif
1269: 
1270: 	#ifndef STANDARD
1271: 		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );
1272: 	#else
1273: 		float clearCoatDHR = 0.0;
1274: 	#endif
1275: 
1276: 	reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );
1277: 
1278: 	reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
1279: 
1280: 	#ifndef STANDARD
1281: 
1282: 		reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );
1283: 
1284: 	#endif
1285: 
1286: }
1287: 
1288: void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
1289: 
1290: 	// Defer to the IndirectSpecular function to compute
1291: 	// the indirectDiffuse if energy preservation is enabled.
1292: 	#ifndef ENVMAP_TYPE_CUBE_UV
1293: 
1294: 		reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
1295: 
1296: 	#endif
1297: 
1298: }
1299: 
1300: void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
1301: 
1302: 	#ifndef STANDARD
1303: 		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
1304: 		float dotNL = dotNV;
1305: 		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );
1306: 	#else
1307: 		float clearCoatDHR = 0.0;
1308: 	#endif
1309: 
1310: 	float clearCoatInv = 1.0 - clearCoatDHR;
1311: 
1312: 	// Both indirect specular and diffuse light accumulate here
1313: 	// if energy preservation enabled, and PMREM provided.
1314: 	#if defined( ENVMAP_TYPE_CUBE_UV )
1315: 
1316: 		vec3 singleScattering = vec3( 0.0 );
1317: 		vec3 multiScattering = vec3( 0.0 );
1318: 		vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
1319: 
1320: 		BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );
1321: 
1322: 		// The multiscattering paper uses the below formula for calculating diffuse 
1323: 		// for dielectrics, but this is already handled when initially computing the 
1324: 		// specular and diffuse color, so we can just use the diffuseColor directly.
1325: 		//vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
1326: 		vec3 diffuse = material.diffuseColor;
1327: 
1328: 		reflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;
1329: 		reflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;
1330: 		reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
1331: 
1332: 	#else
1333: 
1334: 		reflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );
1335: 
1336: 	#endif
1337: 
1338: 	#ifndef STANDARD
1339: 
1340: 		reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );
1341: 
1342: 	#endif
1343: }
1344: 
1345: #define RE_Direct				RE_Direct_Physical
1346: #define RE_Direct_RectArea		RE_Direct_RectArea_Physical
1347: #define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
1348: #define RE_IndirectSpecular		RE_IndirectSpecular_Physical
1349: 
1350: #define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )
1351: #define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )
1352: 
1353: // ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
1354: float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
1355: 
1356: 	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
1357: 
1358: }
1359: 
1360: 
1361: #ifdef USE_SHADOWMAP
1362: 
1363: 	#if 0 > 0
1364: 
1365: 		uniform sampler2D directionalShadowMap[ 0 ];
1366: 		varying vec4 vDirectionalShadowCoord[ 0 ];
1367: 
1368: 	#endif
1369: 
1370: 	#if 0 > 0
1371: 
1372: 		uniform sampler2D spotShadowMap[ 0 ];
1373: 		varying vec4 vSpotShadowCoord[ 0 ];
1374: 
1375: 	#endif
1376: 
1377: 	#if 0 > 0
1378: 
1379: 		uniform sampler2D pointShadowMap[ 0 ];
1380: 		varying vec4 vPointShadowCoord[ 0 ];
1381: 
1382: 	#endif
1383: 	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
1384: 
1385: 		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
1386: 
1387: 	}
1388: 
1389: 	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {
1390: 
1391: 		const vec2 offset = vec2( 0.0, 1.0 );
1392: 
1393: 		vec2 texelSize = vec2( 1.0 ) / size;
1394: 		vec2 centroidUV = floor( uv * size + 0.5 ) / size;
1395: 
1396: 		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );
1397: 		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );
1398: 		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );
1399: 		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );
1400: 
1401: 		vec2 f = fract( uv * size + 0.5 );
1402: 
1403: 		float a = mix( lb, lt, f.y );
1404: 		float b = mix( rb, rt, f.y );
1405: 		float c = mix( a, b, f.x );
1406: 
1407: 		return c;
1408: 
1409: 	}
1410: 
1411: 	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
1412: 
1413: 		float shadow = 1.0;
1414: 
1415: 		shadowCoord.xyz /= shadowCoord.w;
1416: 		shadowCoord.z += shadowBias;
1417: 
1418: 		// if ( something && something ) breaks ATI OpenGL shader compiler
1419: 		// if ( all( something, something ) ) using this instead
1420: 
1421: 		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
1422: 		bool inFrustum = all( inFrustumVec );
1423: 
1424: 		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
1425: 
1426: 		bool frustumTest = all( frustumTestVec );
1427: 
1428: 		if ( frustumTest ) {
1429: 
1430: 		#if defined( SHADOWMAP_TYPE_PCF )
1431: 
1432: 			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
1433: 
1434: 			float dx0 = - texelSize.x * shadowRadius;
1435: 			float dy0 = - texelSize.y * shadowRadius;
1436: 			float dx1 = + texelSize.x * shadowRadius;
1437: 			float dy1 = + texelSize.y * shadowRadius;
1438: 
1439: 			shadow = (
1440: 				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
1441: 				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
1442: 				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
1443: 				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
1444: 				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
1445: 				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
1446: 				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
1447: 				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
1448: 				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
1449: 			) * ( 1.0 / 9.0 );
1450: 
1451: 		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
1452: 
1453: 			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
1454: 
1455: 			float dx0 = - texelSize.x * shadowRadius;
1456: 			float dy0 = - texelSize.y * shadowRadius;
1457: 			float dx1 = + texelSize.x * shadowRadius;
1458: 			float dy1 = + texelSize.y * shadowRadius;
1459: 
1460: 			shadow = (
1461: 				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
1462: 				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
1463: 				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
1464: 				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
1465: 				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +
1466: 				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
1467: 				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
1468: 				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
1469: 				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
1470: 			) * ( 1.0 / 9.0 );
1471: 
1472: 		#else // no percentage-closer filtering:
1473: 
1474: 			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
1475: 
1476: 		#endif
1477: 
1478: 		}
1479: 
1480: 		return shadow;
1481: 
1482: 	}
1483: 
1484: 	// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
1485: 	// vector suitable for 2D texture mapping. This code uses the following layout for the
1486: 	// 2D texture:
1487: 	//
1488: 	// xzXZ
1489: 	//  y Y
1490: 	//
1491: 	// Y - Positive y direction
1492: 	// y - Negative y direction
1493: 	// X - Positive x direction
1494: 	// x - Negative x direction
1495: 	// Z - Positive z direction
1496: 	// z - Negative z direction
1497: 	//
1498: 	// Source and test bed:
1499: 	// https://gist.github.com/tschw/da10c43c467ce8afd0c4
1500: 
1501: 	vec2 cubeToUV( vec3 v, float texelSizeY ) {
1502: 
1503: 		// Number of texels to avoid at the edge of each square
1504: 
1505: 		vec3 absV = abs( v );
1506: 
1507: 		// Intersect unit cube
1508: 
1509: 		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
1510: 		absV *= scaleToCube;
1511: 
1512: 		// Apply scale to avoid seams
1513: 
1514: 		// two texels less per square (one texel will do for NEAREST)
1515: 		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
1516: 
1517: 		// Unwrap
1518: 
1519: 		// space: -1 ... 1 range for each square
1520: 		//
1521: 		// #X##		dim    := ( 4 , 2 )
1522: 		//  # #		center := ( 1 , 1 )
1523: 
1524: 		vec2 planar = v.xy;
1525: 
1526: 		float almostATexel = 1.5 * texelSizeY;
1527: 		float almostOne = 1.0 - almostATexel;
1528: 
1529: 		if ( absV.z >= almostOne ) {
1530: 
1531: 			if ( v.z > 0.0 )
1532: 				planar.x = 4.0 - v.x;
1533: 
1534: 		} else if ( absV.x >= almostOne ) {
1535: 
1536: 			float signX = sign( v.x );
1537: 			planar.x = v.z * signX + 2.0 * signX;
1538: 
1539: 		} else if ( absV.y >= almostOne ) {
1540: 
1541: 			float signY = sign( v.y );
1542: 			planar.x = v.x + 2.0 * signY + 2.0;
1543: 			planar.y = v.z * signY - 2.0;
1544: 
1545: 		}
1546: 
1547: 		// Transform to UV space
1548: 
1549: 		// scale := 0.5 / dim
1550: 		// translate := ( center + 0.5 ) / dim
1551: 		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
1552: 
1553: 	}
1554: 
1555: 	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
1556: 
1557: 		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
1558: 
1559: 		// for point lights, the uniform @vShadowCoord is re-purposed to hold
1560: 		// the vector from the light to the world-space position of the fragment.
1561: 		vec3 lightToPosition = shadowCoord.xyz;
1562: 
1563: 		// dp = normalized distance from light to fragment position
1564: 		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?
1565: 		dp += shadowBias;
1566: 
1567: 		// bd3D = base direction 3D
1568: 		vec3 bd3D = normalize( lightToPosition );
1569: 
1570: 		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )
1571: 
1572: 			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
1573: 
1574: 			return (
1575: 				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
1576: 				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
1577: 				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
1578: 				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
1579: 				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
1580: 				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
1581: 				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
1582: 				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
1583: 				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
1584: 			) * ( 1.0 / 9.0 );
1585: 
1586: 		#else // no percentage-closer filtering
1587: 
1588: 			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
1589: 
1590: 		#endif
1591: 
1592: 	}
1593: 
1594: #endif
1595: 
1596: 
1597: #ifdef USE_BUMPMAP
1598: 
1599: 	uniform sampler2D bumpMap;
1600: 	uniform float bumpScale;
1601: 
1602: 	// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen
1603: 	// http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf
1604: 
1605: 	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)
1606: 
1607: 	vec2 dHdxy_fwd() {
1608: 
1609: 		vec2 dSTdx = dFdx( vUv );
1610: 		vec2 dSTdy = dFdy( vUv );
1611: 
1612: 		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
1613: 		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
1614: 		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
1615: 
1616: 		return vec2( dBx, dBy );
1617: 
1618: 	}
1619: 
1620: 	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {
1621: 
1622: 		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988
1623: 
1624: 		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
1625: 		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
1626: 		vec3 vN = surf_norm;		// normalized
1627: 
1628: 		vec3 R1 = cross( vSigmaY, vN );
1629: 		vec3 R2 = cross( vN, vSigmaX );
1630: 
1631: 		float fDet = dot( vSigmaX, R1 );
1632: 
1633: 		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
1634: 
1635: 		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
1636: 		return normalize( abs( fDet ) * surf_norm - vGrad );
1637: 
1638: 	}
1639: 
1640: #endif
1641: 
1642: 
1643: #ifdef USE_NORMALMAP
1644: 
1645: 	uniform sampler2D normalMap;
1646: 	uniform vec2 normalScale;
1647: 
1648: 	#ifdef OBJECTSPACE_NORMALMAP
1649: 
1650: 		uniform mat3 normalMatrix;
1651: 
1652: 	#else
1653: 
1654: 		// Per-Pixel Tangent Space Normal Mapping
1655: 		// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html
1656: 
1657: 		vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {
1658: 
1659: 			// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988
1660: 
1661: 			vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
1662: 			vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
1663: 			vec2 st0 = dFdx( vUv.st );
1664: 			vec2 st1 = dFdy( vUv.st );
1665: 
1666: 			float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude
1667: 
1668: 			vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );
1669: 			vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );
1670: 			vec3 N = normalize( surf_norm );
1671: 			mat3 tsn = mat3( S, T, N );
1672: 
1673: 			vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
1674: 
1675: 			mapN.xy *= normalScale;
1676: 			mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
1677: 
1678: 			return normalize( tsn * mapN );
1679: 
1680: 		}
1681: 
1682: 	#endif
1683: 
1684: #endif
1685: 
1686: 
1687: #ifdef USE_ROUGHNESSMAP
1688: 
1689: 	uniform sampler2D roughnessMap;
1690: 
1691: #endif
1692: 
1693: 
1694: #ifdef USE_METALNESSMAP
1695: 
1696: 	uniform sampler2D metalnessMap;
1697: 
1698: #endif
1699: 
1700: 
1701: #if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
1702: 
1703: 	uniform float logDepthBufFC;
1704: 	varying float vFragDepth;
1705: 
1706: #endif
1707: 
1708: 
1709: #if 0 > 0
1710: 
1711: 	#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )
1712: 		varying vec3 vViewPosition;
1713: 	#endif
1714: 
1715: 	uniform vec4 clippingPlanes[ 0 ];
1716: 
1717: #endif
1718: 
1719: 
1720: void main() {
1721: 
1722: 
1723: #if 0 > 0
1724: 
1725: 	vec4 plane;
1726: 
1727: 	
1728: 
1729: 	#if 0 < 0
1730: 
1731: 		bool clipped = true;
1732: 
1733: 		
1734: 
1735: 		if ( clipped ) discard;
1736: 
1737: 	#endif
1738: 
1739: #endif
1740: 
1741: 
1742: 	vec4 diffuseColor = vec4( diffuse, opacity );
1743: 	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
1744: 	vec3 totalEmissiveRadiance = emissive;
1745: 
1746: 
1747: #if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
1748: 
1749: 	gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;
1750: 
1751: #endif
1752: 
1753: 
1754: #ifdef USE_MAP
1755: 
1756: 	vec4 texelColor = texture2D( map, vUv );
1757: 
1758: 	texelColor = mapTexelToLinear( texelColor );
1759: 	diffuseColor *= texelColor;
1760: 
1761: #endif
1762: 
1763: 
1764: #ifdef USE_COLOR
1765: 
1766: 	diffuseColor.rgb *= vColor;
1767: 
1768: #endif
1769: 
1770: 
1771: #ifdef USE_ALPHAMAP
1772: 
1773: 	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
1774: 
1775: #endif
1776: 
1777: 
1778: #ifdef ALPHATEST
1779: 
1780: 	if ( diffuseColor.a < ALPHATEST ) discard;
1781: 
1782: #endif
1783: 
1784: 
1785: float roughnessFactor = roughness;
1786: 
1787: #ifdef USE_ROUGHNESSMAP
1788: 
1789: 	vec4 texelRoughness = texture2D( roughnessMap, vUv );
1790: 
1791: 	// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
1792: 	roughnessFactor *= texelRoughness.g;
1793: 
1794: #endif
1795: 
1796: 
1797: float metalnessFactor = metalness;
1798: 
1799: #ifdef USE_METALNESSMAP
1800: 
1801: 	vec4 texelMetalness = texture2D( metalnessMap, vUv );
1802: 
1803: 	// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
1804: 	metalnessFactor *= texelMetalness.b;
1805: 
1806: #endif
1807: 
1808: 
1809: #ifdef FLAT_SHADED
1810: 
1811: 	// Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...
1812: 
1813: 	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
1814: 	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
1815: 	vec3 normal = normalize( cross( fdx, fdy ) );
1816: 
1817: #else
1818: 
1819: 	vec3 normal = normalize( vNormal );
1820: 
1821: 	#ifdef DOUBLE_SIDED
1822: 
1823: 		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
1824: 
1825: 	#endif
1826: 
1827: 	#ifdef USE_TANGENT
1828: 
1829: 		vec3 tangent = normalize( vTangent );
1830: 		vec3 bitangent = normalize( vBitangent );
1831: 
1832: 		#ifdef DOUBLE_SIDED
1833: 
1834: 			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
1835: 			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
1836: 
1837: 		#endif
1838: 
1839: 	#endif
1840: 
1841: #endif
1842: 
1843: 
1844: #ifdef USE_NORMALMAP
1845: 
1846: 	#ifdef OBJECTSPACE_NORMALMAP
1847: 
1848: 		normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals
1849: 
1850: 		#ifdef FLIP_SIDED
1851: 
1852: 			normal = - normal;
1853: 
1854: 		#endif
1855: 
1856: 		#ifdef DOUBLE_SIDED
1857: 
1858: 			normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
1859: 
1860: 		#endif
1861: 
1862: 		normal = normalize( normalMatrix * normal );
1863: 
1864: 	#else // tangent-space normal map
1865: 
1866: 		#ifdef USE_TANGENT
1867: 
1868: 			mat3 vTBN = mat3( tangent, bitangent, normal );
1869: 			vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
1870: 			mapN.xy = normalScale * mapN.xy;
1871: 			normal = normalize( vTBN * mapN );
1872: 
1873: 		#else
1874: 
1875: 			normal = perturbNormal2Arb( -vViewPosition, normal );
1876: 
1877: 		#endif
1878: 
1879: 	#endif
1880: 
1881: #elif defined( USE_BUMPMAP )
1882: 
1883: 	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );
1884: 
1885: #endif
1886: 
1887: 
1888: #ifdef USE_EMISSIVEMAP
1889: 
1890: 	vec4 emissiveColor = texture2D( emissiveMap, vUv );
1891: 
1892: 	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
1893: 
1894: 	totalEmissiveRadiance *= emissiveColor.rgb;
1895: 
1896: #endif
1897: 
1898: 
1899: 	// accumulation
1900: 
1901: PhysicalMaterial material;
1902: material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
1903: material.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );
1904: #ifdef STANDARD
1905: 	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
1906: #else
1907: 	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
1908: 	material.clearCoat = saturate( clearCoat ); // Burley clearcoat model
1909: 	material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );
1910: #endif
1911: 
1912: 
1913: GeometricContext geometry;
1914: 
1915: geometry.position = - vViewPosition;
1916: geometry.normal = normal;
1917: geometry.viewDir = normalize( vViewPosition );
1918: 
1919: IncidentLight directLight;
1920: 
1921: #if ( 0 > 0 ) && defined( RE_Direct )
1922: 
1923: 	PointLight pointLight;
1924: 
1925: 	
1926: 
1927: #endif
1928: 
1929: #if ( 0 > 0 ) && defined( RE_Direct )
1930: 
1931: 	SpotLight spotLight;
1932: 
1933: 	
1934: 
1935: #endif
1936: 
1937: #if ( 0 > 0 ) && defined( RE_Direct )
1938: 
1939: 	DirectionalLight directionalLight;
1940: 
1941: 	
1942: 
1943: #endif
1944: 
1945: #if ( 0 > 0 ) && defined( RE_Direct_RectArea )
1946: 
1947: 	RectAreaLight rectAreaLight;
1948: 
1949: 	
1950: 
1951: #endif
1952: 
1953: #if defined( RE_IndirectDiffuse )
1954: 
1955: 	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
1956: 
1957: 	#if ( 0 > 0 )
1958: 
1959: 		
1960: 
1961: 	#endif
1962: 
1963: #endif
1964: 
1965: #if defined( RE_IndirectSpecular )
1966: 
1967: 	vec3 radiance = vec3( 0.0 );
1968: 	vec3 clearCoatRadiance = vec3( 0.0 );
1969: 
1970: #endif
1971: 
1972: 
1973: #if defined( RE_IndirectDiffuse )
1974: 
1975: 	#ifdef USE_LIGHTMAP
1976: 
1977: 		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;
1978: 
1979: 		#ifndef PHYSICALLY_CORRECT_LIGHTS
1980: 
1981: 			lightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage
1982: 
1983: 		#endif
1984: 
1985: 		irradiance += lightMapIrradiance;
1986: 
1987: 	#endif
1988: 
1989: 	#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )
1990: 
1991: 		irradiance += getLightProbeIndirectIrradiance(  geometry, maxMipLevel );
1992: 
1993: 	#endif
1994: 
1995: #endif
1996: 
1997: #if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
1998: 
1999: 	radiance += getLightProbeIndirectRadiance(  geometry, Material_BlinnShininessExponent( material ), maxMipLevel );
2000: 
2001: 	#ifndef STANDARD
2002: 		clearCoatRadiance += getLightProbeIndirectRadiance(  geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );
2003: 	#endif
2004: 
2005: #endif
2006: 
2007: 
2008: #if defined( RE_IndirectDiffuse )
2009: 
2010: 	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
2011: 
2012: #endif
2013: 
2014: #if defined( RE_IndirectSpecular )
2015: 
2016: 	RE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );
2017: 
2018: #endif
2019: 
2020: 
2021: 	// modulation
2022: 
2023: #ifdef USE_AOMAP
2024: 
2025: 	// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
2026: 	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
2027: 
2028: 	reflectedLight.indirectDiffuse *= ambientOcclusion;
2029: 
2030: 	#if defined( USE_ENVMAP ) && defined( PHYSICAL )
2031: 
2032: 		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
2033: 
2034: 		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
2035: 
2036: 	#endif
2037: 
2038: #endif
2039: 
2040: 
2041: 	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
2042: 
2043: 	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
2044: 
2045: 
2046: #if defined( TONE_MAPPING )
2047: 
2048: 	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
2049: 
2050: #endif
2051: 
2052: 
2053: gl_FragColor = linearToOutputTexel( gl_FragColor );
2054: 
2055: 
2056: #ifdef USE_FOG
2057: 
2058: 	#ifdef FOG_EXP2
2059: 
2060: 		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );
2061: 
2062: 	#else
2063: 
2064: 		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
2065: 
2066: 	#endif
2067: 
2068: 	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
2069: 
2070: #endif
2071: 
2072: 
2073: #ifdef PREMULTIPLIED_ALPHA
2074: 
2075: 	// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.
2076: 	gl_FragColor.rgb *= gl_FragColor.a;
2077: 
2078: #endif
2079: 
2080: 
2081: #if defined( DITHERING )
2082: 
2083: 	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
2084: 
2085: #endif
2086: 
2087: 
2088: }
2089: 